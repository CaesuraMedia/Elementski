// Elemenski javascript library (and globals...)
//
// Elementski provides a simple web interface to Freesound.org (read only, no upload features).  This 
// javascript provides the play, pause, stop and download functions. 
// 
// Each sample has an image, an associated .ogg playable audio file, play/pause button, stop button
// and download button.  When the play button for a sample is pressed, it changes to a pause button 
// and the audio plays.  If the user clicks anywhere in the image, the playback starts from that position.
// When playing, a timeline bar is shown above the image showing where the audio has got to.  When the
// pause button is pressed the audio and timeline stop where they are.  Play again starts from that position
// The Stop button stops audio and resets the bar to the start.   If a sample is playing and a different
// sample has its play button pressed, then all buttons get set to Play and all audio is stopped and the
// new sample is then played.  When the download button is pressed then a progress bar is shown until
// it is fully downloaded when it will vanish.  Downloaded samples will have a flattened download
// button, but it can be pressed for downloading again.
//
// Javascript fuctions :
// stopAllAudio   : When any play button is pressed then stop all other audio playing.
// playthething   : Called from the HTML when a play or stop button is pressed.
// start_download : Called from the HTML when the download button is pressed
// ping           : Called to start with on start_download, then contuously in parse_response_from_cgi until 100%.
// parse_response_from_cgi : Called by ping to read the status of the counter_file, displays a progress bar
//                           and deletes the counter file when 100%.
//
// The ping and parse_response_from_cgi ideas came from Kirsle :
//   https://www.kirsle.net/blog/entry/simple-perl-uploader-with-progress-bar
//
// Most of this javascript uses the id of a Freesound.org sample as id's in the CSS.
//
// AJAX callbacks to Perl CGI :
//
// download.cgi - called by js function start_download when the download button is pressed for a sample, 
//                does the actual download and maintains a download progress counter file.
// ping.cgi     - called by js function ping which is called by start_download to look at the counter
//                file generated by download.cgi.  
// delete_counter.cgi - when the count reaches 100%, delete the counter. Called by js function
//                      parse_response_from_cgi.
//
//
$(document).ready(function() {
   //
});

// Globals, I'll learn OO sometime soon.
//
var audioObjects                = {}; // assoc array, hash, map, whatever. Keys are the freesound id (img_id_8876)
var audioObjectCurrentPositions = {};

// Stops audio and sets all play buttons to Play, except the one that called this function.
// TODO : some of this seems redundant now, version 0.02 will be better.
//
function stopAllAudio (except_this_id) {

   // Stop all audio, even this id.  Probably needs some renaming.
   //
   for (var img_id in audioObjects) {
      audioObjects[img_id].pause();
   }

   // jQuery class is play_button, all of them, except this one, set to show Play button
   //
   $( '.play_image_icon' ).each(function( index ) {

      // 'except_this_id' is img_id_88765, so get its play_button_88765
      // equivalent.
      //
      var except_this_play_button_id = except_this_id.replace(/img_id/, 'play_button');

      if ( this.id !== except_this_play_button_id) {
         this.src = "/img/Play.png";
         console.log ("Setting " + this.id + " to Play");
      } else {
         console.log ("Not Setting " + this.id + " to Play");
      }
   });
}

// Play the selected ogg file audio in an HTML5 audio object. Or stop it.
//
// this_id : img_id_887765 
// ogg_file : full url of the sound file.
// action : 'Play' | 'Stop' string from HTML.
//
function playthething(this_id, ogg_file, action) {

   stopAllAudio(this_id); // stops even this one but leaves the image alone.

   // Create a new audio object if one does not already exist (has been played before).
   //
   var audio;
   if (audioObjects[this_id]) {
      audio = audioObjects[this_id];
   } else {
      audio = new Audio();
      audioObjects[this_id] = audio;
   }
   audio.src = ogg_file;


   // Play/Pause/Stop combos: Both buttons call this function.
   // 
   // Button states : Play, Pause, Stop <-- incoming
   //
   var play_button_id = this_id.replace(/img_id/, 'play_button');
   var play_button_element = document.getElementById (play_button_id);

   console.log ("action is " + action + ", src is " + play_button_element.src);

   // Use the src attr of img to get at what it is doing now.
   //
   var match_play_image  = new RegExp("Play");
   var match_pause_image = new RegExp("Pause");

   if (action === "Play" && match_play_image.test (play_button_element.src)) {

      // Set button state to Pause and play from current position or start.
      //
      play_button_element.src = '/img/Pause.png';

      if (audioObjectCurrentPositions[this_id] > 0) {
         audio.currentTime = audioObjectCurrentPositions[this_id];
      }
      audio.play(); 

   } else if (action === "Play" && match_pause_image.test (play_button_element.src)) {

      // Set button state to Play, pause audio.  Curren position is continually
      // recorded in the listener.
      //
      play_button_element.src = "/img/Play.png";
      audio.pause();

   // Stop should clear everything.
   //
   } else if (action === "Stop") {

      play_button_element.src = '/img/Play.png';
      audio.currentTime = 0;
      audioObjectCurrentPositions[this_id] = 0;
      audio.pause();

      // Move the timeline back to zero.
      //
      var stop_range_id = this_id.replace(/img_id/, 'hp_range');
      var stop_range_elem = document.getElementById(stop_range_id); 
      stop_range_elem.innerHTML = '';
      stop_range_elem.style.width = 0;

   } else {
      console.log ("Error : uncoded button state");
   }


   // This is for the timeline slider - user can click anywhere in the image and 
   // the audio will play from tht position.
   
   // Get rectangle of the image.
   //
   var rect = document.getElementById(this_id).getBoundingClientRect();

   // Event listener to capture current time and show timeline bar.
   //
   audio.addEventListener("timeupdate", function () {

      // img_id_887765 to hp_range_887765
      //
      var hp_range_id = this_id.replace(/img_id/, 'hp_range');

      // Get current time of playing audio.
      //
      var currentTime  = audio.currentTime;

      // Store it globaly for later to resume play from where left off.
      //
      audioObjectCurrentPositions[this_id] = audio.currentTime;  // only seems to be available in this event listener.

      // Calculations to move the slider along with the current time
      //
      var duration     = audio.duration;
      var range_height = rect.bottom - rect.top;
      var range_width  = (currentTime / duration) * (rect.right - rect.left);
      var hp_range_elem = document.getElementById(hp_range_id); 
      var delay_offset = 10;

      // Width = current time / duration.
      //
      hp_range_elem.style.width = delay_offset + range_width + 'px';  // add an offset so it keeps up
      hp_range_elem.innerHTML = '<span class="time_display">' + currentTime + '/' + duration + '</span>';

      // Deal with the offset at the end. Add a bit for the image shadow. Hack.
      //
      if ((delay_offset + range_width) > (rect.right - rect.left)) {
         console.log (hp_range_elem.style.width + " is greater than " + (rect.right - rect.left));
         hp_range_elem.style.width = (rect.right - rect.left) + 2 + "px";
      }

      // When user clicks in the sound image then move the sound and the pointer
      // to that point and keep playing from there.
      //
      $('#' + this_id).click(function(e) {
         var offset   = $(this).offset();
         var mouse_x  = e.pageX - offset.left;
         var mouse_y  = e.pageY - offset.top;
         var new_time = (mouse_x / (rect.right - rect.left)) * audio.duration;

         console.log ("new_time : " + mouse_x + " " + rect.right + " " + rect.left + " " + audio.duration);
         console.log("X : " + mouse_x + ", Y : " + mouse_y + "new time :" + new_time);

         // Force move the current time to the clicked position.
         //
         audio.currentTime = new_time;

      });
      console.log (hp_range_id, currentTime, duration, range_height, range_width);
   });

   // Event listener to set play button to Play when ended.
   //
   audio.addEventListener("ended", function () {
      audioObjectCurrentPositions[this_id] = 0;
      play_button_element.src = '/img/Play.png';
   });

}

// Called by the HTML onclick of download button for this id.
// Async downloads!  Click on lots of download buttons and they will all fire
// this function, which does an async call to the Perl CGI.  That download.cgi
// creates a counter file with download progress for reading by ping.
//
function start_download(freesound_sample_id) {
   console.log ("Download called on " + freesound_sample_id);
   var ajax = new XMLHttpRequest();

   // Just start the download and begin pinging the counter file.
   //
   ajax.onreadystatechange = function () {
      if (ajax.readyState == 4) {
      }
   };
   ajax.open("GET", "/cgi-bin/elementski/download.cgi?id=" + freesound_sample_id, true);
   ajax.send(null);

   // Ping the CGI for status.
   //
   setTimeout(ping(freesound_sample_id), 100);
}

// Calls the Perl CGI ping.cgi to get the contents of the counter_file and send it to
// parse_response_from_cgi for  drawing the download progess bar.
//
function ping (freesound_sample_id) {
   console.log ("Ping called : " + freesound_sample_id);
   
   var ajax = new XMLHttpRequest();

   ajax.onreadystatechange = function () {
      if (ajax.readyState == 4) {
         parse_response_from_cgi(ajax.responseText, freesound_sample_id);
      }
   };

   ajax.open("GET", "/cgi-bin/elementski/ping.cgi?id=" + freesound_sample_id, true);
   ajax.send(null);

}

// Over-complex code to draw a progress bar from the counter_file updated by download.cgi
// Format of the file is :1234:6543:78 - bytes written, bytes total, percentage.
// Also provides some error handling too, if not authorised by Freesound to download then the 
// counter_file will have "auth_error" in or other errors which we can print to screen.
//
function parse_response_from_cgi (response, freesound_sample_id) {

   console.log ("wibble parse_response_from_cgi called :" + freesound_sample_id + " : Response : " + response);
   
   // id : download_[% id_num %]"
   //
   // Ping the CGI for status.
   // 1234:6543:78
   //
   var parts = response.split(":");
   console.log (parts[0], parts[1],parts[2]);

   // These are the container and bar for each of the samples shown.
   //
   var download_container = document.getElementById('download_container_' + freesound_sample_id);
   var download_bar       = document.getElementById('download_bar_'       + freesound_sample_id);

   if (parts[0] === "auth_error") {

      // Create a box with auth error and refresh instrucion.
      //
      console.log ("In auth error bit");
      download_container.style.border = "1px solid green";
      download_container.style.width  = "250px";
      download_container.style.float  = "right";
      download_container.style.margin = "1px";
      download_container.innerHTML    = "<p class=no_auth_text>No authorisation to download, please refresh page.</p>";

      // Delete the counter file.
      //
      $.ajax(
         {url:     "/cgi-bin/elementski/delete_counter.cgi?id=" + freesound_sample_id,
          success: function(result){ 
             console.log ("Response from delete on auth error : " + result + ", Progress : " + parts[2]);
          }
         }
      ); 

   } else {

      // Move the download slider alog,
      //
      var download_width  = parts[2] + "%";

      // Open up the Container.
      //
      download_container.style.border    = "1px solid green";
      download_container.style.width     = "250px";
      download_container.style.float     = "right";
      download_container.style.marginTop = "5px";

      // Move along the bar.
      //
      download_bar.style.width           = download_width;
      download_bar.style.border          = "1px solid blue";
      download_bar.style.height          = "5px";
      download_bar.style.background      = "blue";

      // Just a nice thing - remove the boxShadow from the download button
      // to show that it already has been downloaded.  The button will still
      // actually work to dowload it again if required.
      //
      var download_button_element = document.getElementById ('download_' + freesound_sample_id);
      download_button_element.style.boxShadow = '0px 0px 0px #000000';
      
      // Keep pinging until 100% in parts[2].
      //
      if (parts[2] === null || parts[2] < 100 || typeof parts[2] === "undefined") {
         setTimeout(ping(freesound_sample_id), 100);
      } else {

         // All complete at 100% download, delete the counter file. Hide the download bar.
         //
         $.ajax({url: "/cgi-bin/elementski/delete_counter.cgi?id=" + freesound_sample_id,
            success: function(result){
               console.log ("Response from delete : " + result + ", Progress : " + parts[2]);

               // Hide the container.
               //
               download_container.style.border         = "0px solid white";
               download_container.style.marginTop      = "0px";

               // Hide the bar.
               //
               download_bar.style.border               = "0px solid blue";
               download_bar.style.height               = "0px";
               download_bar.style.background           = "white";
         }});
      }
   }
}

// Copyright 2016 Andy Cragg.
// 
// This program is free software; you can redistribute it and/or modify it
// under the terms of the the Perl Artistic License (2.0). You may obtain a
// copy of the full license at:
//
// http://www.perlfoundation.org/artistic_license_2_0

